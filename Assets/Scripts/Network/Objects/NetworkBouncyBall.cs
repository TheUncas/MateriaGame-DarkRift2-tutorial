using DarkRift;
using DarkRift.Server;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class NetworkBouncyBall : NetworkObject
{

    #region Properties
    public Rigidbody rigidbodyReference;

    /// <summary>
    /// Last received message from the server
    /// </summary>
    public BouncyBallSyncMessageModel lastReceivedMessage;

    /// <summary>
    /// Tick counted by the client
    /// </summary>
    public int clientTick = -1;

    /// <summary>
    /// Contains data wich will be generated by the client
    /// </summary>
    public List<BouncyBallSyncMessageModel> reconciliationInfoList;


    #endregion

    // Start is called before the first frame update
    public override void Start()
    {
        base.Start();

        ////////////////////////////////////
        // Get references
        rigidbodyReference = GetComponent<Rigidbody>();

        //If we are on client side
        if (!Equals(ClientManager.instance, null))
        {
            //////////////////
            /// Suscribe to events
            ClientManager.instance.clientReference.MessageReceived += UpdateFromServerState;
            reconciliationInfoList = new List<BouncyBallSyncMessageModel>();
        }
    }

    private void OnDestroy()
    {
        //If we are on client side
        if (!Equals(ClientManager.instance, null))
        {
            ClientManager.instance.clientReference.MessageReceived -= UpdateFromServerState;
        }
    }

    private void FixedUpdate()
    {
        //If we are on server side
        if (!Equals(GameServerManager.instance, null))
        {
            if (GameServerManager.instance.currentTick % 10 == 0)
                SendBallPositionToClients();
        }
        else if (!Equals(ClientManager.instance, null) && clientTick != -1)
        {
            clientTick++;
            reconciliationInfoList.Add(new BouncyBallSyncMessageModel
            {
                position = transform.position,
                serverTick = clientTick,
                velocity = rigidbodyReference.velocity
            });

            Reconciliate();
        }
    }

    // Update is called once per frame
    void Update()
    {

    }

    /// <summary>
    /// Send ball server position to all clients
    /// </summary>
    private void SendBallPositionToClients()
    {
        //Create the message
        BouncyBallSyncMessageModel bouncyBallPositionMessageData = new BouncyBallSyncMessageModel
        {
            networkID = base.id,
            serverTick = GameServerManager.instance.currentTick,
            position = rigidbodyReference.transform.position,
            velocity = rigidbodyReference.velocity
        };

        //create the message 
        using (Message m = Message.Create(
            NetworkTags.InGame.BOUNCY_BALL_SYNC_POS,        //Tag
            bouncyBallPositionMessageData)                  //Data
        )
        {
            foreach (IClient client in GameServerManager.instance.serverReference.Server.ClientManager.GetAllClients())
            {
                client.SendMessage(m, SendMode.Reliable);
            }
        }
    }

    /// <summary>
    /// update from the server state
    /// </summary>
    /// <param name="sender"></param>
    /// <param name="e"></param>
    private void UpdateFromServerState(object sender, DarkRift.Client.MessageReceivedEventArgs e)
    {
        if (e.Tag == NetworkTags.InGame.BOUNCY_BALL_SYNC_POS)
        {
            //Get message data
            BouncyBallSyncMessageModel syncMessage = e.GetMessage().Deserialize<BouncyBallSyncMessageModel>();

            //If this is the first time we receive the message
            if (Object.Equals(null, lastReceivedMessage))
            {
                //Update data
                rigidbodyReference.velocity = syncMessage.velocity;
                rigidbodyReference.transform.position = syncMessage.position;
                clientTick = syncMessage.serverTick;
                lastReceivedMessage = syncMessage;
            }

            //If the message regards this object and is older than the previous one
            if (id == syncMessage.networkID && syncMessage.serverTick > lastReceivedMessage.serverTick)
            {
                lastReceivedMessage = syncMessage;
            }
        }
    }

    /// <summary>
    /// Reconciliate the client with the server data
    /// </summary>
    private void Reconciliate()
    {
        if (reconciliationInfoList.Count() > 0)
        {
            //Get the position of the client at this specific frame
            BouncyBallSyncMessageModel clientInfo = reconciliationInfoList.Where(i => i.serverTick == lastReceivedMessage.serverTick).FirstOrDefault();

            //If there is more than 50 tick that the ball has not been updated depending to the server position
            if (reconciliationInfoList.Count() > 50)
            {
                rigidbodyReference.velocity = lastReceivedMessage.velocity;
                rigidbodyReference.transform.position = lastReceivedMessage.position;
                clientTick = lastReceivedMessage.serverTick;
                clientInfo = lastReceivedMessage;
            }                

            if (!Equals(clientInfo, null))
            {
                //Check for position divergence
                if (Vector3.Distance(clientInfo.position, lastReceivedMessage.position) >= 0.05f)
                {
                    //Update data
                    rigidbodyReference.velocity = lastReceivedMessage.velocity;
                    rigidbodyReference.transform.position = lastReceivedMessage.position;
                }

                //Empty the list
                reconciliationInfoList.Clear();
            }            
        }
    }
}
